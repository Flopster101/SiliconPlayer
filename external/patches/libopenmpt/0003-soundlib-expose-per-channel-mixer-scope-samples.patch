From b81b5de94c7a4275a13d6d0dac5fe2d19ddd93b2 Mon Sep 17 00:00:00 2001
From: Codex <codex@local>
Date: Mon, 16 Feb 2026 15:10:50 -0300
Subject: [PATCH 3/6] soundlib: expose per-channel mixer scope samples

---
 libopenmpt/libopenmpt.hpp      | 10 +++++
 libopenmpt/libopenmpt_cxx.cpp  |  3 ++
 libopenmpt/libopenmpt_impl.cpp |  7 ++++
 libopenmpt/libopenmpt_impl.hpp |  1 +
 soundlib/Fastmix.cpp           | 11 ++++++
 soundlib/Sndfile.cpp           | 70 ++++++++++++++++++++++++++++++++++
 soundlib/Sndfile.h             | 12 ++++++
 7 files changed, 114 insertions(+)

diff --git a/libopenmpt/libopenmpt.hpp b/libopenmpt/libopenmpt.hpp
index 36e57bf02..55c8fbdf9 100644
--- a/libopenmpt/libopenmpt.hpp
+++ b/libopenmpt/libopenmpt.hpp
@@ -949,6 +949,16 @@ public:
 	  \remarks The returned value is solely based on the note velocity and does not take the actual waveform of the playing sample into account.
 	*/
 	LIBOPENMPT_CXX_API_MEMBER float get_current_channel_vu_rear_right( std::int32_t channel ) const;
+	//! Get a per-channel waveform scope slice from recent mixer output.
+	/*!
+	  \param channel The channel whose scope waveform should be retrieved.
+	  \param scope Destination buffer to write waveform samples into.
+	  \param count Number of samples requested in scope.
+	  \return Number of samples written (same as count on success, 0 on invalid arguments).
+	  \remarks Samples are normalized floating point in range [-1.0, +1.0].
+	  \since 0.8.0
+	*/
+	LIBOPENMPT_CXX_API_MEMBER std::int32_t get_current_channel_scope( std::int32_t channel, float * scope, std::int32_t count ) const;
 
 	//! Get the number of sub-songs
 	/*!
diff --git a/libopenmpt/libopenmpt_cxx.cpp b/libopenmpt/libopenmpt_cxx.cpp
index d85b8ac0f..b6f335a49 100644
--- a/libopenmpt/libopenmpt_cxx.cpp
+++ b/libopenmpt/libopenmpt_cxx.cpp
@@ -361,6 +361,9 @@ float module::get_current_channel_vu_rear_left( std::int32_t channel ) const {
 float module::get_current_channel_vu_rear_right( std::int32_t channel ) const {
 	return impl->get_current_channel_vu_rear_right( channel );
 }
+std::int32_t module::get_current_channel_scope( std::int32_t channel, float * scope, std::int32_t count ) const {
+	return impl->get_current_channel_scope( channel, scope, count );
+}
 
 std::int32_t module::get_num_subsongs() const {
 	return impl->get_num_subsongs();
diff --git a/libopenmpt/libopenmpt_impl.cpp b/libopenmpt/libopenmpt_impl.cpp
index 4b826fca5..82daf260b 100644
--- a/libopenmpt/libopenmpt_impl.cpp
+++ b/libopenmpt/libopenmpt_impl.cpp
@@ -1407,6 +1407,13 @@ float module_impl::get_current_channel_vu_rear_right( std::int32_t channel ) con
 	}
 	return m_sndFile->m_PlayState.Chn[channel].dwFlags[OpenMPT::CHN_SURROUND] ? m_sndFile->m_PlayState.Chn[channel].nRightVU * (1.0f/128.0f) : 0.0f;
 }
+std::int32_t module_impl::get_current_channel_scope( std::int32_t channel, float * scope, std::int32_t count ) const {
+	if(scope == nullptr || count <= 0 || channel < 0 || channel >= m_sndFile->GetNumChannels())
+	{
+		return 0;
+	}
+	return m_sndFile->GetChannelScopeSamples(static_cast<OpenMPT::CHANNELINDEX>(channel), scope, count);
+}
 
 std::int32_t module_impl::get_num_subsongs() const {
 	std::unique_ptr<subsongs_type> subsongs_temp = has_subsongs_inited() ? std::unique_ptr<subsongs_type>() : std::make_unique<subsongs_type>( get_subsongs() );
diff --git a/libopenmpt/libopenmpt_impl.hpp b/libopenmpt/libopenmpt_impl.hpp
index 7e5faac4b..dfc211b10 100644
--- a/libopenmpt/libopenmpt_impl.hpp
+++ b/libopenmpt/libopenmpt_impl.hpp
@@ -239,6 +239,7 @@ public:
 	float get_current_channel_vu_right( std::int32_t channel ) const;
 	float get_current_channel_vu_rear_left( std::int32_t channel ) const;
 	float get_current_channel_vu_rear_right( std::int32_t channel ) const;
+	std::int32_t get_current_channel_scope( std::int32_t channel, float * scope, std::int32_t count ) const;
 	std::int32_t get_num_subsongs() const;
 	std::int32_t get_num_channels() const;
 	std::int32_t get_num_orders() const;
diff --git a/soundlib/Fastmix.cpp b/soundlib/Fastmix.cpp
index 40bae2458..1e407a9b4 100644
--- a/soundlib/Fastmix.cpp
+++ b/soundlib/Fastmix.cpp
@@ -460,11 +460,22 @@ bool CSoundFile::MixChannel(int count, ModChannel &chn, CHANNELINDEX channel, bo
 				mixsample_t *pbufmax = pbuffer + (nSmpCount * 2);
 				chn.nROfs = -*(pbufmax - 2);
 				chn.nLOfs = -*(pbufmax - 1);
+				const bool captureScope = (channel != CHANNELINDEX_INVALID && channel < GetNumChannels());
+				std::array<mixsample_t, MIXBUFFERSIZE * 2> scopeBefore;
+				mixsample_t *scopeAfter = pbuffer;
+				if(captureScope)
+				{
+					std::memcpy(scopeBefore.data(), pbuffer, static_cast<std::size_t>(nSmpCount * 2) * sizeof(mixsample_t));
+				}
 
 #ifdef MPT_BUILD_DEBUG
 				SamplePosition targetpos = chn.position + chn.increment * nSmpCount;
 #endif
 				MixFuncTable::Functions[functionNdx | (chn.nRampLength ? MixFuncTable::ndxRamp : 0)](chn, m_Resampler, pbuffer, nSmpCount);
+				if(captureScope)
+				{
+					PushChannelScopeDiff(channel, scopeBefore.data(), scopeAfter, nSmpCount);
+				}
 #ifdef MPT_BUILD_DEBUG
 				MPT_ASSERT(chn.position.GetUInt() == targetpos.GetUInt());
 #endif
diff --git a/soundlib/Sndfile.cpp b/soundlib/Sndfile.cpp
index 3b863bcba..821d9c51f 100644
--- a/soundlib/Sndfile.cpp
+++ b/soundlib/Sndfile.cpp
@@ -904,9 +904,78 @@ double CSoundFile::GetCurrentBPM() const
 	return bpm;
 }
 
+int32 CSoundFile::GetChannelScopeSamples(CHANNELINDEX channel, float *output, int32 sampleCount) const
+{
+	if(output == nullptr || sampleCount <= 0 || channel >= MAX_CHANNELS)
+	{
+		return 0;
+	}
+	const ChannelScopeBuffer &buffer = m_channelScopeBuffers[channel];
+	const uint32 requestCount = static_cast<uint32>(sampleCount);
+	const uint32 copyCount = std::min(requestCount, std::min<uint32>(buffer.available, static_cast<uint32>(kChannelScopeBufferSize)));
+	const uint32 padCount = requestCount - copyCount;
+	for(uint32 i = 0; i < padCount; ++i)
+	{
+		output[i] = 0.0f;
+	}
+	uint32 readPos = (buffer.writePos + static_cast<uint32>(kChannelScopeBufferSize) - copyCount) % static_cast<uint32>(kChannelScopeBufferSize);
+	for(uint32 i = 0; i < copyCount; ++i)
+	{
+		output[padCount + i] = buffer.data[readPos];
+		readPos++;
+		if(readPos >= kChannelScopeBufferSize)
+		{
+			readPos = 0;
+		}
+	}
+	return sampleCount;
+}
+
+void CSoundFile::ResetChannelScopeBuffers()
+{
+	for(auto &buffer : m_channelScopeBuffers)
+	{
+		buffer.data.fill(0.0f);
+		buffer.writePos = 0;
+		buffer.available = 0;
+	}
+}
+
+void CSoundFile::PushChannelScopeDiff(CHANNELINDEX channel, const mixsample_t *before, const mixsample_t *after, int32 sampleCount)
+{
+	if(channel >= MAX_CHANNELS || before == nullptr || after == nullptr || sampleCount <= 0)
+	{
+		return;
+	}
+	ChannelScopeBuffer &buffer = m_channelScopeBuffers[channel];
+#ifdef MPT_INTMIXER
+	const float intToFloat = m_PlayConfig.getIntToFloat();
+	const float scale = intToFloat * 0.5f;
+#else
+	const float scale = 0.5f;
+#endif
+	for(int32 i = 0; i < sampleCount; ++i)
+	{
+		const int32 interleavedIndex = i * 2;
+		const float left = static_cast<float>(after[interleavedIndex + 0] - before[interleavedIndex + 0]);
+		const float right = static_cast<float>(after[interleavedIndex + 1] - before[interleavedIndex + 1]);
+		buffer.data[buffer.writePos] = std::clamp((left + right) * scale, -1.0f, 1.0f);
+		buffer.writePos++;
+		if(buffer.writePos >= kChannelScopeBufferSize)
+		{
+			buffer.writePos = 0;
+		}
+		if(buffer.available < kChannelScopeBufferSize)
+		{
+			buffer.available++;
+		}
+	}
+}
+
 
 void CSoundFile::ResetPlayPos()
 {
+	ResetChannelScopeBuffers();
 	const auto muteFlag = GetChannelMuteFlag();
 	for(CHANNELINDEX i = 0; i < m_PlayState.Chn.size(); i++)
 		m_PlayState.Chn[i].Reset(ModChannel::resetSetPosFull, *this, i, muteFlag);
@@ -970,6 +1039,7 @@ void CSoundFile::SetCurrentOrder(ORDERINDEX nOrder)
 		ResetPlayPos();
 	} else
 	{
+		ResetChannelScopeBuffers();
 		m_PlayState.m_nNextOrder = nOrder;
 		m_PlayState.m_nRow = m_PlayState.m_nNextRow = 0;
 		m_PlayState.m_nPattern = 0;
diff --git a/soundlib/Sndfile.h b/soundlib/Sndfile.h
index 943819603..56f99e0bc 100644
--- a/soundlib/Sndfile.h
+++ b/soundlib/Sndfile.h
@@ -58,6 +58,7 @@
 #include "../common/FileReaderFwd.h"
 
 #include <vector>
+#include <array>
 #include <bitset>
 #include <set>
 
@@ -444,6 +445,14 @@ private:
 	// End-of-sample pop reduction tail level
 	mixsample_t m_dryLOfsVol = 0, m_dryROfsVol = 0;
 	mixsample_t m_surroundLOfsVol = 0, m_surroundROfsVol = 0;
+	static constexpr std::size_t kChannelScopeBufferSize = 16384;
+	struct ChannelScopeBuffer
+	{
+		std::array<float, kChannelScopeBufferSize> data{};
+		uint32 writePos = 0;
+		uint32 available = 0;
+	};
+	std::array<ChannelScopeBuffer, MAX_CHANNELS> m_channelScopeBuffers{};
 
 public:
 	MixerSettings m_MixerSettings;
@@ -749,6 +758,8 @@ public:
 	void DontLoopPattern(PATTERNINDEX nPat, ROWINDEX nRow = 0);
 	CHANNELINDEX GetMixStat() const { return m_nMixStat; }
 	void ResetMixStat() { m_nMixStat = 0; }
+	int32 GetChannelScopeSamples(CHANNELINDEX channel, float *output, int32 sampleCount) const;
+	void ResetChannelScopeBuffers();
 	void ResetPlayPos();
 	void SetCurrentOrder(ORDERINDEX nOrder);
 	std::string GetTitle() const { return m_songName; }
@@ -992,6 +1003,7 @@ private:
 	void ProcessDSP(uint32 countChunk);
 	void ProcessPlugins(uint32 nCount);
 	void ProcessInputChannels(IAudioSource &source, std::size_t countChunk);
+	void PushChannelScopeDiff(CHANNELINDEX channel, const mixsample_t *before, const mixsample_t *after, int32 sampleCount);
 public:
 	samplecount_t GetTotalSampleCount() const { return m_PlayState.m_lTotalSampleCount; }
 	bool HasPositionChanged() { bool b = m_PlayState.m_flags[SONG_POSITIONCHANGED]; m_PlayState.m_flags.reset(SONG_POSITIONCHANGED); return b; }
-- 
2.53.0

